---
// src/pages/[lang]/about.astro
import AppShell from '../../app/layouts/AppShell.astro';
import { getEntry, getCollection } from 'astro:content';
import { registry } from '../../features/about/registry';
import { debug } from '../../app/shared/lib/conditional-debug';
import { fromMarkdownSections } from '../../features/about/lib/markdownMapper';
import seed from '../../content/blocks/skills.seed.json';

const { lang } = Astro.params as { lang: 'en' | 'ru' };
const slug = `${lang}/about`;

// Helper functions for i18n
const t = (obj: any, lang: 'en' | 'ru') => (typeof obj === 'object' && obj ? obj[lang] ?? obj.en ?? '' : obj ?? '');
const buildSkillsFromSeed = (seed: any, lang: 'en' | 'ru') => ({
  type: 'skills',
  data: {
    title: t(seed.title, lang),
    groups: seed.groups.map((g: any) => ({
      title: t(g.title, lang),
      items: (g.items ?? []).map((it: any) => ({
        name: t(it.name, lang),
        icon: it.icon,
        url: it.url,
        level: it.level,
        description: t(it.description, lang)
      }))
    }))
  }
});

// Try to read about-expanded.md first
let entry = await getEntry({ collection: 'aboutPage', slug: `${lang}/about-expanded` });

// Fallback to about.md if about-expanded.md doesn't exist
if (!entry) {
  debug('[about] about-expanded.md not found, trying about.md');
  entry = await getEntry({ collection: 'aboutPage', slug });
}

// Final fallback - search through all entries
if (!entry) {
  const all = await getCollection('aboutPage');
  debug('[about] NOT FOUND slug=%s. Available slugs:', slug, all.map(e => e.slug));
  entry = all.find(e => e.slug === slug || (e.slug.startsWith(`${lang}/`) && e.slug.endsWith('/about')));
}

debug('[about] lang=%s slug=%s found=%s', lang, slug, !!entry);

// Section normalization functions
const keys = (o:any) => o ? Object.keys(o) : [];
const getType = (s:any) =>
  s?.type ?? s?.template ?? s?.blockType ?? s?.component ?? s?.data?.type ?? 'unknown';

const mapType = (t:string) => {
  const k = (t||'').toLowerCase();
  const m: Record<string, string> = {
    skills: 'skills', skill: 'skills',
    grid: 'cards', list: 'cards'
    // keep others as-is or add more mappings if needed
  };
  return m[k] ?? k;
};

const normalize = (s:any) => ({ ...s, type: mapType(getType(s)), data: s?.data ?? s });

// Process sections with comprehensive logging
let rawSections = entry?.data?.sections ?? [];
debug('[about] sections.total=%d', rawSections.length);

// если из CMS секций нет → отдаем skills из seed
if (!rawSections?.length) {
  debug('[about] using SEED fallback for skills');
  rawSections = [buildSkillsFromSeed(seed, lang)];
}

rawSections.forEach((s:any, i:number) => {
  debug('[about] s[%d] keys=%o', i, keys(s));
  debug('[about] s[%d] typeGuess=%s dataKeys=%o', i, getType(s), keys(s?.data));
});

// Use the new mapper to transform sections with fallbacks
const mappedSections = fromMarkdownSections(rawSections);
const sections = Object.values(mappedSections);
const types = sections.map(s=>s.type);
debug('[about] mapped types=%o', types);
const unknown = sections.filter(s=>!registry[s.type]);
if (unknown.length) debug('[about] UNKNOWN types=%o', unknown.map(u=>u.type));

// Section hygiene: filter out empty sections
const isEmpty = (section: any) => {
  const type = section.type;
  const data = section.data || {};
  
  // Check explicit visibility
  if (data.visible === false) {
    debug('[about] skip %s (reason: visible=false)', type);
    return true;
  }
  
  // Check section-specific emptiness
  switch (type) {
    case 'skills':
      const groups = data.groups || [];
      const hasItems = groups.some((g: any) => (g.items || []).length > 0);
      if (!hasItems) {
        debug('[about] skip %s (reason: empty)', type);
        return true;
      }
      break;
      
    case 'experience':
    case 'education':
      const items = data.items || [];
      if (items.length === 0) {
        debug('[about] skip %s (reason: empty)', type);
        return true;
      }
      break;
      
    case 'favorites':
      const favGroups = data.groups || [];
      const hasFavItems = favGroups.some((g: any) => (g.items || []).length > 0);
      if (!hasFavItems) {
        debug('[about] skip %s (reason: empty)', type);
        return true;
      }
      break;
  }
  
  return false;
};

const filteredSections = sections.filter(section => !isEmpty(section));
debug('[about] filtered sections: %d -> %d', sections.length, filteredSections.length);

// Enhanced logging for skills sections
sections.forEach((section: any, i: number) => {
  if (section.type === 'skills' && section.data?.groups) {
    debug('[about] skills section[%d]: groups=%d', i, section.data.groups.length);
    section.data.groups.forEach((group: any, gi: number) => {
      debug('[about]   group[%d]: title="%s" items=%d', gi, group.title, group.items?.length || 0);
    });
  }
});

// Add first section sample logging
if (sections.length) debug('[about] first section sample=%o', sections[0]);
---

<AppShell lang={lang}>
  <div id="site-container" class="site-container py-8">
    {filteredSections.length === 0
      ? <p class="text-gray-500 dark:text-gray-400">Контент готовится…</p>
      : filteredSections.map((section) => {
          const Comp = registry[section.type];
          if (!Comp) {
            debug('[about] skip unknown section type=%s', section?.type);
            return <div class="rounded-lg border border-dashed border-gray-300/50 p-4 text-sm text-gray-500 dark:text-gray-400">
              Unknown section: <b>{section?.type ?? 'undefined'}</b>
            </div>;
          }
          return <Comp section={section} lang={lang} frontmatter={entry?.data} />;
        })}
    
    <script is:inline>
      (function(){
        const c=document.getElementById('site-container');
        if(!c){ if(import.meta.env.DEV) console.warn('[about] #site-container missing'); return; }
        const cs=getComputedStyle(c);
        if(import.meta.env.DEV) console.debug('[about] container width=%s padX=%s/%s', c.offsetWidth, cs.paddingLeft, cs.paddingRight);
      })();
    </script>
  </div>
</AppShell>

<style>
  html {
    scroll-behavior: smooth;
  }

  /* Ensure proper spacing for sticky navbar */
  body {
    margin: 0;
    padding: 0;
  }
</style>

<script>
  // Redirect from #bookme to /bookme page
  if (typeof window !== 'undefined' && location.hash === '#bookme') {
    location.replace(`/${lang}/bookme`);
  }
</script>
