---
// src/pages/[lang]/about.astro
import AppShell from '../../app/layouts/AppShell.astro';
import { getEntry, getCollection } from 'astro:content';
import { registry } from '../../features/about/registry';
import { debug } from '../../app/shared/lib/conditional-debug';
import { fromMarkdownSections } from '../../features/about/lib/markdownMapper';
import seed from '../../content/blocks/skills.seed.json';

const { lang } = Astro.params as { lang: 'en' | 'ru' };
const slug = `${lang}/about`;

// Helper functions for i18n
const t = (obj: any, lang: 'en' | 'ru') => (typeof obj === 'object' && obj ? obj[lang] ?? obj.en ?? '' : obj ?? '');
const buildSkillsFromSeed = (seed: any, lang: 'en' | 'ru') => ({
  type: 'skills',
  data: {
    title: t(seed.title, lang),
    groups: seed.groups.map((g: any) => ({
      title: t(g.title, lang),
      items: (g.items ?? []).map((it: any) => ({
        name: t(it.name, lang),
        icon: it.icon,
        url: it.url,
        level: it.level,
        description: t(it.description, lang)
      }))
    }))
  }
});

// Load the canonical about-expanded.md file
let entry = await getEntry({ collection: 'aboutPage', slug: `${lang}/about-expanded` });

// No fallback - fail fast if the canonical file doesn't exist
if (!entry) {
  throw new Error(`About page content not found for language: ${lang}. Expected file: ${lang}/about-expanded.md`);
}

debug('[about] lang=%s slug=%s found=%s', lang, `${lang}/about-expanded`, !!entry);

// Section normalization functions
const keys = (o:any) => o ? Object.keys(o) : [];
const getType = (s:any) =>
  s?.type ?? s?.template ?? s?.blockType ?? s?.component ?? s?.data?.type ?? 'unknown';

const mapType = (t:string) => {
  const k = (t||'').toLowerCase();
  const m: Record<string, string> = {
    skills: 'skills', skill: 'skills',
    grid: 'cards', list: 'cards',
    media: 'media', medias: 'media'
    // keep others as-is or add more mappings if needed
  };
  return m[k] ?? k;
};

const normalize = (s:any) => ({ ...s, type: mapType(getType(s)), data: s?.data ?? s });

// Process sections with comprehensive logging
let rawSections = entry?.data?.sections ?? [];
debug('[about] sections.total=%d', rawSections.length);

// если из CMS секций нет → отдаем skills из seed
if (!rawSections?.length) {
  debug('[about] using SEED fallback for skills');
  rawSections = [buildSkillsFromSeed(seed, lang)];
}

rawSections.forEach((s:any, i:number) => {
  debug('[about] s[%d] keys=%o', i, keys(s));
  debug('[about] s[%d] typeGuess=%s dataKeys=%o', i, getType(s), keys(s?.data));
});

// Use the new mapper to transform sections with fallbacks
const mappedSections = fromMarkdownSections(rawSections);
const sections = Object.values(mappedSections);

// Safe media section mapping - handle both 'media' and 'medias' keys with tolerant mapping
const mediaSections = sections.filter(s => s.type === 'media' || s.type === 'medias');
const mediaItems = mediaSections.flatMap(s => (s.data?.items ?? s.data?.list ?? s.data?.data ?? []));

// Log media items for debugging
if (mediaItems.length > 0) {
  debug('[about] found %d media items', mediaItems.length);
}

const types = sections.map(s=>s.type);
debug('[about] mapped types=%o', types);
debug('[about] mapped sections keys=%o', Object.keys(mappedSections));
debug('[about] main section exists=%s', !!mappedSections.main);
if (mappedSections.main) {
  debug('[about] main section data keys=%o', Object.keys(mappedSections.main.data || {}));
}
const unknown = sections.filter(s=>!registry[s.type]);
if (unknown.length) debug('[about] UNKNOWN types=%o', unknown.map(u=>u.type));

// Locale parity guard: ensure RU sections match EN order/types
if (lang === 'ru' && import.meta.env.DEV) {
  const enEntry = await getEntry({ collection: 'aboutPage', slug: 'en/about-expanded' });
  if (enEntry?.data?.sections) {
    const enMappedSections = fromMarkdownSections(enEntry.data.sections);
    const enSections = Object.values(enMappedSections);
    const enTypes = enSections.map(s => s.type);
    
    if (JSON.stringify(enTypes) !== JSON.stringify(types)) {
      console.warn('[about] Locale parity mismatch detected:');
      console.warn('[about] EN section order:', enTypes);
      console.warn('[about] RU section order:', types);
      
      // Reorder RU sections to match EN order
      const reorderedSections: any[] = [];
      enTypes.forEach(enType => {
        const ruSection = sections.find(s => s.type === enType);
        if (ruSection) {
          reorderedSections.push(ruSection);
        }
      });
      
      // Add any RU sections not in EN (shouldn't happen after sync)
      sections.forEach(ruSection => {
        if (!enTypes.includes(ruSection.type)) {
          reorderedSections.push(ruSection);
        }
      });
      
      // Replace the sections array with reordered version
      sections.splice(0, sections.length, ...reorderedSections);
      console.warn('[about] RU sections reordered to match EN order:', sections.map(s => s.type));
    }
  }
}

// Section hygiene: filter out empty sections
const isEmpty = (section: any) => {
  const type = section.type;
  const data = section.data || {};
  
  // Check explicit visibility
  if (data.visible === false) {
    debug('[about] skip %s (reason: visible=false)', type);
    return true;
  }
  
  // Check section-specific emptiness
  switch (type) {
    case 'main':
      // Main section should always be shown if visible is not explicitly false
      if (data.visible === false) {
        debug('[about] skip %s (reason: visible=false)', type);
        return true;
      }
      // Additional checks for main section completeness
      if (!data.fullName || !data.role) {
        debug('[about] skip %s (reason: missing required fields)', type);
        return true;
      }
      break;
      
    case 'skills':
      const groups = data.groups || [];
      const hasItems = groups.some((g: any) => (g.items || []).length > 0);
      if (!hasItems) {
        debug('[about] skip %s (reason: empty)', type);
        return true;
      }
      break;
      
    case 'experience':
    case 'education':
      const items = data.items || [];
      if (items.length === 0) {
        debug('[about] skip %s (reason: empty)', type);
        return true;
      }
      break;
      
    case 'brands':
      const brandItems = data.items || [];
      if (brandItems.length === 0) {
        debug('[about] skip %s (reason: empty)', type);
        return true;
      }
      break;
      
    case 'favorites':
      const favGroups = data.groups || [];
      const hasFavItems = favGroups.some((g: any) => (g.items || []).length > 0);
      if (!hasFavItems) {
        debug('[about] skip %s (reason: empty)', type);
        return true;
      }
      break;
  }
  
  return false;
};

const filteredSections = sections.filter(section => !isEmpty(section));
debug('[about] filtered sections: %d -> %d', sections.length, filteredSections.length);

// Log each section that passes filtering
filteredSections.forEach((section, i) => {
  debug('[about] filtered section[%d]: type=%s, visible=%s', i, section.type, section.data?.visible);
});

// Enhanced logging for skills sections
sections.forEach((section: any, i: number) => {
  if (section.type === 'skills' && section.data?.groups) {
    debug('[about] skills section[%d]: groups=%d', i, section.data.groups.length);
    section.data.groups.forEach((group: any, gi: number) => {
      debug('[about]   group[%d]: title="%s" items=%d', gi, group.title, group.items?.length || 0);
    });
  }
});

// Add first section sample logging
if (sections.length) debug('[about] first section sample=%o', sections[0]);
---

<AppShell lang={lang}>
  <div id="site-container" class="site-container py-8">
    {filteredSections.length === 0
      ? <p class="text-gray-500 dark:text-gray-400">Контент готовится…</p>
      : filteredSections.map((section) => {
          const Comp = registry[section.type];
          if (!Comp) {
            debug('[about] skip unknown section type=%s', section?.type);
            return <div class="rounded-lg border border-dashed border-gray-300/50 p-4 text-sm text-gray-500 dark:text-gray-400">
              Unknown section: <b>{section?.type ?? 'undefined'}</b>
            </div>;
          }
          return <Comp section={section} lang={lang} frontmatter={entry?.data} mediaItems={mediaItems} />;
        })}
    
    <script>
      (function(){
        const c=document.getElementById('site-container');
        if(!c){ console.warn('[about] #site-container missing'); return; }
        const cs=getComputedStyle(c);
        console.debug('[about] container width=%s padX=%s/%s', c.offsetWidth, cs.paddingLeft, cs.paddingRight);
      })();
    </script>
  </div>
</AppShell>

<style>
  html {
    scroll-behavior: smooth;
  }

  /* Ensure proper spacing for sticky navbar */
  body {
    margin: 0;
    padding: 0;
  }
</style>

<script>
  // Redirect from #bookme to /bookme page
  if (typeof window !== 'undefined' && location.hash === '#bookme') {
    location.replace(`/${lang}/bookme`);
  }
</script>
