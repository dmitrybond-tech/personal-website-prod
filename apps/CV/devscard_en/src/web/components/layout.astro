---
import type { Config, Sections } from '@/types/data';
import Head from '@/web/head/head.astro';

export interface Props extends Config {
  sections: Sections;
}

const { meta, i18n, sections } = Astro.props;
---

<!DOCTYPE html>
<html lang={i18n.locale.code} class="scroll-smooth">
  <Head meta={meta} sections={sections} />
  <body class="flex justify-center overflow-x-hidden bg-gray-50 dark:bg-gray-900 xl:relative xl:left-7">
    <slot />
    <script>
      const sendHeight = () => {
        const el = document.scrollingElement || document.documentElement;
        parent.postMessage({ type:'cv-embed-height', height: el.scrollHeight }, '*');
      };

      // реагируем на ВСЁ, чтобы не оставалось внутреннего скролла
      ['load','resize','hashchange'].forEach(ev => window.addEventListener(ev, () => {
        requestAnimationFrame(()=>{ setTimeout(sendHeight, 0); setTimeout(sendHeight, 250); });
      }));
      new ResizeObserver(sendHeight).observe(document.documentElement);
      // когда шрифты/картинки догрузятся
      if (document.fonts?.ready) document.fonts.ready.then(()=>{ sendHeight(); setTimeout(sendHeight,150); });
      Array.from(document.images||[]).forEach(img => {
        if (!img.complete) img.addEventListener('load', ()=> setTimeout(sendHeight,50), {once:true});
      });

      // обработчик cv-goto уже есть; после scrollIntoView добавь повторный sendHeight
      // window.addEventListener('message', ... ) → после скролла setTimeout(sendHeight, 50/300)
        const map = {
          profile: 'profile',
          skills: 'skills',
          experience: 'experience',
          education: 'education',
          portfolio: 'portfolio',
          contact: 'contact'
        };
        return map[anchor] || 'profile';
      };

      window.addEventListener('message', (e) => {
        const data = e?.data || {};
        if (data.type === 'cv-goto') {
          const anchor = idFor(String(data.anchor || ''));
          // меняем hash (даёт историю и тултипы), а затем скроллим
          if (location.hash !== '#' + anchor) location.hash = anchor;
          const el = document.getElementById(anchor);
          if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
          // после скролла обновим высоту
          setTimeout(sendHeight, 50);
          setTimeout(sendHeight, 300);
        }
      }, false);

      // helper: определяем текущую секцию на основе IntersectionObserver
      const anchors = ['profile','skills','experience','education','portfolio','contact'];
      const sections = anchors.map(id => document.getElementById(id)).filter(Boolean);

      let current = 'profile';
      const notify = (name) => {
        if (current === name) return;
        current = name;
        parent.postMessage({ type: 'cv-section', anchor: current }, '*');
      };

      const io = new IntersectionObserver((entries) => {
        const visible = entries
          .filter(e => e.isIntersecting)
          .sort((a,b) => a.boundingClientRect.top - b.boundingClientRect.top);
        if (visible[0]?.target?.id) notify(visible[0].target.id);
      }, { rootMargin: '-30% 0px -60% 0px', threshold: [0, .2, .6] });

      sections.forEach(s => s && io.observe(s));

      // ещё репортим при hashchange
      window.addEventListener('hashchange', () => {
        const id = location.hash.replace('#','');
        if (anchors.includes(id)) notify(id);
      });
    </script>
  </body>
</html>
